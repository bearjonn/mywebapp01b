<!DOCTYPE html>
<html lang="no">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Galaxion â€“ Piskel-sprites med lyd (osc/MP3) â€“ FIXED</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0f19;color:#e7eefc;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .wrap{display:grid;place-items:center;height:100%}
    canvas{background:#040710;border:2px solid #1e2b4a;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.5);image-rendering:pixelated}
    .hint{position:fixed;inset:auto 0 12px 0;text-align:center;opacity:.85;font-size:14px}
    .hint code{background:#0b1224;padding:.12rem .35rem;border-radius:.35rem}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="480" height="640"></canvas>
  </div>
  <div class="hint">
    Sprites (samme mappe): <code>player.png</code>, <code>enemy_red.png</code>, <code>enemy_yellow.png</code>, <code>enemy_green.png</code>, <code>bullet.png</code>, <code>ebullet.png</code>, (valgfritt) <code>explosion.png</code>.
    Lydmodus: sett <code>SOUND_MODE</code> til <code>'osc'</code>, <code>'mp3'</code> eller <code>'off'</code>. MP3-filer: <code>shoot.mp3</code>, <code>enemy_shoot.mp3</code>, <code>hit.mp3</code>, <code>explode.mp3</code>, <code>wave.mp3</code>, <code>dive.mp3</code>.
  </div>

  <script>
  // =============================================================
  //  Galaxion (undervisningsdemo) â€“ Piskel-sprites + lyd (osc/MP3)
  //  FIXES:
  //   - Deklarerer "ready" korrekt (ReferenceError i tidligere versjon)
  //   - Sikrere tilgang til assets i draw()
  //   - Ryddigere init-rekkefÃ¸lge og Ã©n startWave-kall
  // =============================================================

  const SOUND_MODE = 'mp3'; // 'osc' | 'mp3' | 'off'

  const W=480, H=640;
  const cvs=document.getElementById('game');
  const ctx=cvs.getContext('2d');
  ctx.imageSmoothingEnabled=false;

  // ---------- Lydsystem ----------
  let AC=null, audioUnlocked=false;
  const MP3 = {}; // navn -> HTMLAudioElement

  const MP3_FILES = {
    shoot: '/images/shoot.mp3',
    enemy_shoot: '/images/enemy_shoot.mp3',
    hit: '/images/hit.mp3',
    explode: '/images/explode.mp3',
    wave: '/images/wave.mp3',
    dive: '/images/dive.mp3'
  };
  for (const [k,src] of Object.entries(MP3_FILES)){
    const a = new Audio(); a.src = src; a.preload = 'auto'; a.volume = 0.6; MP3[k] = a;
  }

  function unlockAudio(){
    if (audioUnlocked) return;
    if (!AC) AC = new (window.AudioContext||window.webkitAudioContext)();
    if (AC.state === 'suspended') AC.resume();
    audioUnlocked = true;
  }
  ['pointerdown','keydown'].forEach(ev=> addEventListener(ev, unlockAudio, { once:true }));

  function playOsc({freq=440, dur=0.06, type='square', gain=0.04}){
    if (SOUND_MODE !== 'osc') return;
    if (!AC) AC = new (window.AudioContext||window.webkitAudioContext)();
    const o = AC.createOscillator();
    const g = AC.createGain();
    o.type = type; o.frequency.value = freq; g.gain.value = gain;
    o.connect(g); g.connect(AC.destination);
    const t = AC.currentTime;
    o.start(t); o.stop(t + dur);
  }

  function playMP3(name){
    if (SOUND_MODE !== 'mp3') return;
    const base = MP3[name]; if (!base) return;
    const a = base.cloneNode(); a.volume = base.volume; a.play().catch(()=>{});
  }

  const SFX = {
    shoot(){ if (SOUND_MODE==='mp3') playMP3('shoot'); else if (SOUND_MODE==='osc') playOsc({freq:720,dur:0.05,type:'square',gain:0.035}); },
    enemyShoot(){ if (SOUND_MODE==='mp3') playMP3('enemy_shoot'); else if (SOUND_MODE==='osc') playOsc({freq:240,dur:0.06,type:'triangle',gain:0.03}); },
    hit(){ if (SOUND_MODE==='mp3') playMP3('hit'); else if (SOUND_MODE==='osc') playOsc({freq:220,dur:0.08,type:'square',gain:0.06}); },
    explode(){ if (SOUND_MODE==='mp3') playMP3('explode'); else if (SOUND_MODE==='osc') playOsc({freq:560,dur:0.05,type:'sawtooth',gain:0.035}); },
    wave(){ if (SOUND_MODE==='mp3') playMP3('wave'); else if (SOUND_MODE==='osc') playOsc({freq:660,dur:0.10,type:'triangle',gain:0.04}); },
    dive(){ if (SOUND_MODE==='mp3') playMP3('dive'); else if (SOUND_MODE==='osc') playOsc({freq:300,dur:0.08,type:'sine',gain:0.04}); }
  };

  // ---------- Sprites (Piskel) ----------
  const SCALE = 2; // 16x16 â†’ 32x32
  const ASSETS = {
    player:      { src:'/images/player.png',       fw:16, fh:16, frames:4, cols:4, fps:8 },
    enemy_red:   { src:'/images/enemy_red.png',    fw:16, fh:16, frames:2, cols:2, fps:6 },
    enemy_yellow:{ src:'/images/enemy_yellow.png', fw:16, fh:16, frames:2, cols:2, fps:6 },
    enemy_green: { src:'/images/enemy_green.png',  fw:16, fh:16, frames:2, cols:2, fps:6 },
    bullet:      { src:'/images/bullet.png',       fw:4,  fh:8,  frames:1, cols:1, fps:0 },
    ebullet:     { src:'/images/ebullet.png',      fw:4,  fh:8,  frames:1, cols:1, fps:0 },
    explosion:   { src:'/images/explosion.png',    fw:16, fh:16, frames:6, cols:6, fps:12, once:true }
  };

  function loadImage(src){ return new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=()=>res(null); img.src=src; }); }
  async function loadAssets(){
    const out={};
    for(const [key,conf] of Object.entries(ASSETS)){
      const img = await loadImage(conf.src);
      out[key] = img ? { img, ...conf } : null; // tillat manglende filer uten crash
    }
    return out;
  }

  class Sprite {
    constructor(asset){ Object.assign(this, asset); this.time=0; this.frame=0; }
    update(dt){ if(!this || !this.img || this.fps<=0 || this.frames<=1) return; this.time+=dt; const ms=1000/this.fps; while(this.time>=ms){ this.time-=ms; this.frame=(this.frame+1)%this.frames; } }
    draw(x,y,flip=false){
      if(this && this.img){
        const col = this.cols ? (this.frame % this.cols) : 0;
        const row = this.cols ? (this.frame / this.cols | 0) : 0;
        const sx = col * this.fw, sy = row * this.fh;
        const dx = Math.round(x - (this.fw*SCALE)/2);
        const dy = Math.round(y - (this.fh*SCALE)/2);
        if(flip){ ctx.save(); ctx.translate(dx+this.fw*SCALE/2, dy+this.fh*SCALE/2); ctx.scale(-1,1); ctx.drawImage(this.img, sx,sy,this.fw,this.fh, -(this.fw*SCALE)/2, -(this.fh*SCALE)/2, this.fw*SCALE, this.fh*SCALE); ctx.restore(); }
        else ctx.drawImage(this.img, sx,sy,this.fw,this.fh, dx,dy, this.fw*SCALE, this.fh*SCALE);
      } else { ctx.fillStyle='#7dd3fc'; ctx.fillRect(Math.round(x-8),Math.round(y-8),16,16); }
    }
  }

  // ---------- Spilltilstand ----------
  let assets=null, ready=false; // IMPORTANT: ready mÃ¥ vÃ¦re deklarert
  let score=0, wave=1, lives=3; let gameOver=false, youWin=false;
  const keys={};
  const player={ x:W/2, y:H-56, w:32, h:32, speed:4.0, cooldown:0, invuln:0, spr:null };
  const shots=[], enemyShots=[], particles=[];
  const enemies=[]; const rows=5, cols=8; const gapX=48, gapY=36; const startX=56, startY=84;
  let enemyDX=0.9, stepDown=18, enemyFireTimer=1000, enemyDiveTimer=2200;

  function playerBox(){ return {x:player.x-16,y:player.y-12,w:32,h:28}; }
  function rect(a,b){ return !(a.x+a.w<b.x||a.x>b.x+b.w||a.y+a.h<b.y||a.y>b.y+b.h); }
  function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }

  function spriteForRow(r){
    if(!assets) return null;
    return r===0? (assets.enemy_red? new Sprite(assets.enemy_red):null)
                : (r<3? (assets.enemy_yellow? new Sprite(assets.enemy_yellow):null)
                       : (assets.enemy_green? new Sprite(assets.enemy_green):null));
  }

  function resetEnemies(){
    enemies.length=0;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        enemies.push({ x:startX+c*gapX, y:startY+r*gapY, w:32, h:32, alive:true, row:r, mode:'formation', vx:0, vy:0, spr: spriteForRow(r) });
      }
    }
  }
  function startWave(n){
    wave=n; enemyDX=0.9*Math.pow(1.08,wave-1);
    enemyFireTimer=Math.max(380, 1000-(wave-1)*70);
    enemyDiveTimer=Math.max(1200, 2400-(wave-1)*160);
    resetEnemies();
  }

  function restart(){ score=0; lives=3; Object.assign(player,{x:W/2,y:H-56,cooldown:0,invuln:0}); shots.length=0; enemyShots.length=0; particles.length=0; gameOver=false; youWin=false; startWave(1); }

  function firePlayer(){ if(player.cooldown>0) return; shots.push({x:player.x,y:player.y-12,w:8,h:12,vy:-6}); player.cooldown=150; SFX.shoot(); }
  function fireEnemy(){ const alive=enemies.filter(e=>e.alive); if(!alive.length) return; alive.sort((a,b)=>b.y-a.y); const e=alive[Math.floor(Math.random()*Math.min(6,alive.length))]; enemyShots.push({x:e.x,y:e.y+16,w:8,h:12,vy:3+0.15*wave}); SFX.enemyShoot(); }

  function explode(x,y){ for(let i=0;i<18;i++){ const a=Math.random()*Math.PI*2; const sp=1+Math.random()*3; particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:420}); } SFX.explode(); }

  // Input
  addEventListener('keydown',e=>{ keys[e.code]=true; if(e.code==='KeyR') restart(); });
  addEventListener('keyup',e=>{ keys[e.code]=false; });

  // Loop
  let last=performance.now();
  function frame(t){ const dt=t-last; last=t; update(dt); draw(dt); requestAnimationFrame(frame); }

  function update(dt){
    if(!ready || gameOver || youWin) return;

    if(player.spr) player.spr.update(dt);

    // Spiller
    if(keys['ArrowLeft']||keys['KeyA']) player.x-=player.speed;
    if(keys['ArrowRight']||keys['KeyD']) player.x+=player.speed;
    player.x=clamp(player.x,24,W-24);
    if(keys['Space']) firePlayer();
    if(player.cooldown>0) player.cooldown-=dt; if(player.invuln>0) player.invuln-=dt;

    // Skudd
    for(let i=shots.length-1;i>=0;i--){ const s=shots[i]; s.y+=s.vy; if(s.y+s.h<0) shots.splice(i,1); }
    for(let i=enemyShots.length-1;i>=0;i--){ const s=enemyShots[i]; s.y+=s.vy; if(s.y>H) enemyShots.splice(i,1); }

    // Partikler
    for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.015; p.life-=dt; if(p.life<=0) particles.splice(i,1); }

    // Fiender
    let minX=Infinity,maxX=-Infinity, anyAlive=false;
    for(const e of enemies){ if(!e.alive) continue; anyAlive=true; if(e.spr) e.spr.update(dt);
      if(e.mode==='formation'){ e.x+=enemyDX; minX=Math.min(minX,e.x-16); maxX=Math.max(maxX,e.x+16); }
      else { const steer=((player.x-e.x)*0.0025)*dt; e.vx=clamp(e.vx+steer,-2.2,2.2); e.vy=clamp(e.vy+0.0025*dt,2.2,5.2); e.x+=e.vx; e.y+=e.vy; if(e.y>H+40){ e.y=startY-20; e.mode='formation'; e.vx=0; e.vy=0; } }
    }
    if(anyAlive && (minX<16||maxX>W-16)){ enemyDX=-enemyDX; for(const e of enemies){ if(e.alive && e.mode==='formation') e.y+=stepDown; } enemyDX*=1.05; }

    // Kollisjon: spillerâ†’fiende
    for(let i=shots.length-1;i>=0;i--){ const s=shots[i]; let hit=false; for(const e of enemies){ if(!e.alive) continue; if(rect({x:s.x-4,y:s.y-6,w:8,h:12},{x:e.x-16,y:e.y-16,w:32,h:32})){ e.alive=false; score+=10; explode(e.x,e.y); hit=true; break; } } if(hit) shots.splice(i,1); }

    // Kollisjon: fiende/fiendekuleâ†’spiller
    if(player.invuln<=0){
      for(let i=enemyShots.length-1;i>=0;i--){ const s=enemyShots[i]; if(rect({x:s.x-4,y:s.y-6,w:8,h:12}, playerBox())){ enemyShots.splice(i,1); explode(player.x,player.y); loseLife(); break; } }
      for(const e of enemies){ if(e.alive && e.mode!=='formation' && rect(playerBox(), {x:e.x-16,y:e.y-16,w:32,h:32})){ e.alive=false; explode(player.x,player.y); loseLife(); break; } }
      for(const e of enemies){ if(e.alive && e.mode==='formation' && (e.y+16)>=player.y){ gameOver=true; } }
    }

    // BÃ¸lge ferdig?
    if(enemies.every(e=>!e.alive)) { if(wave>=6){ youWin=true; } else nextWave(); }

    // Timere
    enemyFireTimer-=dt; if(enemyFireTimer<=0){ fireEnemy(); enemyFireTimer=Math.max(220,900-wave*80); }
    enemyDiveTimer-=dt; if(enemyDiveTimer<=0){ launchDiver(); enemyDiveTimer=Math.max(800,2200-wave*140); }
  }

  function draw(){
    // Bakgrunn
    ctx.fillStyle='#050814'; ctx.fillRect(0,0,W,H);
    for(let i=0;i<70;i++){ const x=(i*67%W); const y=(i*131%H); ctx.fillStyle=i%7===0?'#7dd3fc':'#93c5fd'; ctx.fillRect((x+performance.now()/70)%W, y, 2, 2); }

    // UI
    ctx.fillStyle='#e7eefc'; ctx.font='16px system-ui, sans-serif';
    ctx.fillText('SCORE: '+score,16,24); ctx.fillText('WAVE: '+wave, W/2-28,24); ctx.fillText('LIV: '+lives, W-90,24);

    // Spiller
    if(!(player.invuln>0 && Math.floor(performance.now()/120)%2===0))
      (player.spr? player.spr : dummySprite(16,16)).draw(player.x, player.y);

    // Skudd
    const sprBullet = assets && assets.bullet ? new Sprite(assets.bullet) : null;
    const sprEBullet = assets && assets.ebullet ? new Sprite(assets.ebullet) : null;
    for(const s of shots){ (sprBullet || dummySprite(4,8)).draw(s.x, s.y); }
    for(const s of enemyShots){ (sprEBullet || dummySprite(4,8)).draw(s.x, s.y); }

    // Fiender
    for(const e of enemies){ if(!e.alive) continue; (e.spr? e.spr : dummySprite(16,16)).draw(e.x, e.y); }

    // Partikler
    for(const p of particles){ ctx.fillStyle='#ffd166'; ctx.fillRect(p.x, p.y, 2, 2); }

    if(gameOver||youWin){ ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(0,0,W,H); ctx.fillStyle=youWin?'#7ef29a':'#ff8fa3'; ctx.font='bold 28px system-ui, sans-serif'; ctx.textAlign='center'; ctx.fillText(youWin?'SEIER! ðŸŽ‰':'GAME OVER',W/2,H/2-12); ctx.font='16px system-ui, sans-serif'; ctx.fillStyle='#e7eefc'; ctx.fillText('Trykk R for Ã¥ restarte', W/2, H/2+16); ctx.textAlign='start'; }
  }

  function dummySprite(w,h){ return { draw:(x,y)=>{ ctx.fillStyle='#7dd3fc'; ctx.fillRect(Math.round(x-w),Math.round(y-h),w*2,h*2); } }; }

  function launchDiver(){ const cand=enemies.filter(e=>e.alive && e.mode==='formation'); if(!cand.length) return; cand.sort((a,b)=>a.row-b.row || Math.random()-0.5); const e=cand[0]; e.mode='dive'; e.vx=(Math.random()<0.5?-1:1)*1.2; e.vy=2.2; SFX.dive(); }
  function loseLife(){ lives--; SFX.hit(); if(lives<=0){ gameOver=true; return; } player.x=W/2; player.invuln=1400; }
  function nextWave(){ shots.length=0; enemyShots.length=0; particles.length=0; startWave(wave+1); SFX.wave(); }

  // --- Start alt ---
  (async function(){
    assets = await loadAssets();
    player.spr = assets && assets.player ? new Sprite(assets.player) : null;
    ready = true;            // <â€” var definert Ã¸verst
    startWave(1);            // initier fÃ¸rste bÃ¸lge ETTER at assets er lastet
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
